/* autogenerated by Processing revision 1297 on 2025-06-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import com.heroicrobot.controlsynthesis.*;
import com.heroicrobot.dropbit.discovery.*;
import com.heroicrobot.dropbit.common.*;
import com.heroicrobot.dropbit.registry.*;
import com.heroicrobot.dropbit.devices.*;
import com.heroicrobot.dropbit.devices.pixelpusher.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class renderer extends PApplet {









class TestObserver implements Observer {
  public boolean hasStrips = false;
  public void update(Observable registry, Object updatedDevice) {
    println("Registry changed!");
    if (updatedDevice != null) {
      println("Device change: " + updatedDevice);
    }
    this.hasStrips = true;
  }
}

// load devices
DeviceRegistry registry;
TestObserver testObserver;
// load data (defaults);
FrameData frameData;
// load fonts
PFont h1Font;
PFont h2Font;
PFont h3Font;
// changed
boolean isChanged = false;

// START: helper methods for rendering
public void resetBackground() {
  background(frameData.arcadeBackground);
}
public String padZeros(int num, int sf) {
  return String.format("%0" + Integer.toString(sf) + "d", num).replace(' ', '0');
}
// END: of helper methods

public void settings() {
  size(FrameData.widthTotal, FrameData.heightTotal);
}

public void setup() {
  // initialize fonts
  h1Font = createFont(FrameData.fontName, FrameData.h1FontSizePx);
  h2Font = createFont(FrameData.fontName, FrameData.h2FontSizePx);
  h3Font = createFont(FrameData.fontName, FrameData.h3FontSizePx);

  // create default frame data
  // modify FrameData based on arguments, you can find the variables in FrameData.pde
  ArgumentParser parser = new ArgumentParser(args);
  if (args != null && args.length > 0) {
    println("Processing received arguments: " + Arrays.toString(args));
    frameData = parser.toFrameData();
  } else {
    println("No arguments received, using default values.");
    FrameDataBuilder builder = new FrameDataBuilder();
    frameData = builder.build();
  }
  isChanged = true; // set changed to true, so we can render frame data
  // check if we're to save preview only, or to render frame data continuously
  if (parser.toSavePreview()) {
    println("Saving preview and exiting...");
    preview(frameData);
    save(parser.getSavePreviewLocation());
    exit();
  } else {
    println("Rendering frame data...");
    // initialize registry
    registry = new DeviceRegistry();
    testObserver = new TestObserver();
    registry.addObserver(testObserver);
    // render frame data
    background(0);
    resetBackground();
    renderFrameData(frameData);
  }
}

public void draw() {
  if (testObserver.hasStrips) {
    if (isChanged) {
      loadPixels();
      registry.startPushing();
      List<Strip> strips = registry.getStrips();
      // iterate through each available strips, and sample pixels
      int y = 0;
      int scaleY = height / (strips.size());
      for (Strip strip: strips) {
        int scaleX = width / strip.getLength();
        for (int x = 0; x < strip.getLength(); x++) {
          int c = pixels[y*scaleY*width+x*scaleX];
          // color c = get(x*scaleX, y*scaleY); // this is a slower, but what was written in docs
          strip.setPixel(c, x);
        }
        y++;
      }
      isChanged = false;
      delay(100); // wait a bit, so we can see the data
    } else {
      // clean up registry, so there's no updating (hence no flickering)
      delay(100);
      registry.stopPushing();
    }
  }
}


public void renderStringRow(String str, int x, int y, int colour) {
  textAlign(CENTER);
  rectMode(CENTER);
  fill(colour);
  text(str, x, y);
}

public void renderFrameData(FrameData dt) {
  // set modes
  rectMode(CENTER);
  imageMode(CENTER);

  // load images
  PImage p1Img = loadImage(dt.p1ImgSrc);
  PImage p2Img = loadImage(dt.p2ImgSrc);

  // resize & fill image to container & render p1 & p2 images
  int imgSize = (int) Math.floor(FrameData.imgContainerSizePx * FrameData.imgDpSize * FrameData.imgScale);
  SquareFill p1ImgDim = new SquareFill(p1Img.width, p1Img.height, imgSize);
  p1Img.resize(p1ImgDim.w, p1ImgDim.h); // order is important
  SquareCrop p1ImgCrop = new SquareCrop(p1Img.width, p1Img.height, imgSize);
  p1Img = p1Img.get(p1ImgCrop.x, p1ImgCrop.y, p1ImgCrop.w, p1ImgCrop.h);
  image(p1Img, dt.widthCenter - (2 * FrameData.ledPanelWidth * FrameData.imgDpSize), dt.heightCenter);
  SquareFill p2ImgDim = new SquareFill(p2Img.width, p2Img.height, imgSize);
  p2Img.resize(p2ImgDim.w, p2ImgDim.h); // order is important
  SquareCrop p2ImgCrop = new SquareCrop(p2Img.width, p2Img.height, imgSize);
  p2Img = p2Img.get(p2ImgCrop.x, p2ImgCrop.y, p2ImgCrop.w, p2ImgCrop.h);
  image(p2Img, dt.widthCenter + (2 * FrameData.ledPanelWidth * FrameData.imgDpSize), dt.heightCenter);

  // render title row
  textFont(h1Font);
  fill(255);
  renderStringRow("LIFC 2025: RETRO ARCADE", dt.widthCenter, 50, dt.arcadeMagenta);

  // render top score row
  int centerX = dt.widthCenter;
  fill(dt.arcadeRed);
  rect(centerX, 86, 128, 40, 32);
  textFont(h2Font);
  renderStringRow("TOP", centerX, 100, color(255));
  renderStringRow(padZeros(dt.topScore, 7), centerX, 140, dt.arcadeWhite);

  // render p1 & p2 player score rows
  int middleOffsetX = -4;
  int leftX = centerX - (FrameData.ledPanelWidth + middleOffsetX) * FrameData.imgDpSize + 40;
  int rightX = centerX + (FrameData.ledPanelWidth + middleOffsetX) * FrameData.imgDpSize - 40;
  renderStringRow("1UP", leftX, 160, dt.arcadeCyan);
  renderStringRow(padZeros(dt.p1Score, 7), leftX, 200, dt.arcadeWhite);
  renderStringRow(dt.p1Name.substring(0, Math.min(dt.p1Name.length(), 10)), leftX, 240, dt.arcadeOrange);
  renderStringRow("2UP", rightX, 160, dt.arcadeCyan);
  renderStringRow(padZeros(dt.p2Score, 7), rightX, 200, dt.arcadeWhite);
  renderStringRow(dt.p2Name.substring(0, Math.min(dt.p2Name.length(), 10)), rightX, 240, dt.arcadeOrange);
}

// this method will output attempt to estimate what would it look like on the actual display
public void preview(FrameData dt) {
  background(0); // led panel are black in colour, so background is black
  renderFrameData(dt);
  // render the preview
  rectMode(CORNER);
  loadPixels();
  for (int x = 0; x < width; x += dt.imgDpSize) {
    for (int y = 0; y < height; y += dt.imgDpSize) {
      int offset = 0; // (int) Math.floor((dt.imgDpSize) / 2);
      int c = pixels[(y + offset) * width + (x + offset)];
      fill(c);
      stroke(0);
      int s = (int) Math.floor(dt.imgDpSize / dt.pixelPitch);
      square(x, y, s);
      noFill();
      noStroke();
    }
  }
}
// Class for animating a sequence of GIFs

class Animation {
  PImage[] images;
  int imageCount;
  int frame;

  Animation(String imagePrefix, int count) {
    imageCount = count;
    images = new PImage[imageCount];

    for (int i = 0; i < imageCount; i++) {
      // Use nf() to number format 'i' into four digits
      String filename = imagePrefix + nf(i, 4) + ".gif";
      images[i] = loadImage(filename);
    }
  }

  public void display(float xpos, float ypos) {
    frame = (frame+1) % imageCount;
    image(images[frame], xpos, ypos);
  }

  public int getWidth() {
    return images[0].width;
  }
}
class ArgumentParser {
  HashMap<String, String> options = new HashMap<>();

  ArgumentParser(String[] args) {
    for (String arg : args) {
      if (arg.startsWith("--")) {
        String[] split = arg.substring(2).split("=");
        if (split.length == 2) {
          this.options.put(split[0], split[1]);
        }
      }
      // else, skip if it's not a valid argument
    }
  }

  public boolean toSavePreview() {
    String savePreview = options.get("savePreview");
    return savePreview != null && !savePreview.trim().isEmpty();
  }

  public String getSavePreviewLocation() { 
    return options.get("savePreview");
  }

  public FrameData toFrameData() {
    String p1Name = options.get("p1Name");
    String p1ImgSrc = options.get("p1ImgSrc");
    String p1ScoreStr = options.get("p1Score");
    String p2Name = options.get("p2Name");
    String p2ImgSrc = options.get("p2ImgSrc");
    String p2ScoreStr = options.get("p2Score");
    String topScoreStr = options.get("topScore");

    FrameDataBuilder builder = new FrameDataBuilder();
    if (p1Name != null && !p1Name.trim().isEmpty()) { builder.p1Name(p1Name); }
    if (p1ImgSrc != null && !p1ImgSrc.trim().isEmpty()) { builder.p1ImgSrc(p1ImgSrc); }
    if (p1ScoreStr != null && !p1ScoreStr.trim().isEmpty()) {
      try {
        int p1Score = Integer.parseInt(p1ScoreStr);
        builder.p1Score(p1Score);
      } catch (NumberFormatException e) {
        println("Invalid p1Score: " + p1ScoreStr);
      }
    }
    if (p2Name != null && !p2Name.trim().isEmpty()) { builder.p2Name(p2Name); }
    if (p2ImgSrc != null && !p2ImgSrc.trim().isEmpty()) { builder.p2ImgSrc(p2ImgSrc); }
    if (p2ScoreStr != null && !p2ScoreStr.trim().isEmpty()) {
      try {
        int p2Score = Integer.parseInt(p2ScoreStr);
        builder.p2Score(p2Score);
      } catch (NumberFormatException e) {
        println("Invalid p2Score: " + p2ScoreStr);
      }
    }
    if (topScoreStr != null && !topScoreStr.trim().isEmpty()) {
      try {
        int topScore = Integer.parseInt(topScoreStr);
        builder.topScore(topScore);
      } catch (NumberFormatException e) {
        println("Invalid topScore: " + topScoreStr);
      }
    }
    return builder.build();
  }
}
class FrameData {
  //VARIABLES
  private String p1Name;
  private String p1ImgSrc;
  private int p1Score;
  private String p2Name;
  private String p2ImgSrc;
  private int p2Score;
  private int topScore;
  //CONSTANTS
  //hardware
  static final private int ledPanelHeight = 64;
  static final private int ledPanelWidth = 64;
  static final private int ledPanelHCount = 5; // tiled horizontally
  static final private int ledPanelVCount = 1; // tiled vertically
  //images
  static final private int imgContainerSizePx = 64;
  static final private int imgDpSize = 4;
  static final private float imgScale = 0.9f;
  //positions
  static final private int widthTotal = ledPanelWidth * ledPanelHCount * imgDpSize;
  final private int widthCenter = Math.floorDiv(ledPanelWidth * ledPanelHCount, 2) * imgDpSize;
  static final private int heightTotal = ledPanelHeight * ledPanelVCount * imgDpSize;
  final private int heightCenter = Math.floorDiv(ledPanelHeight * ledPanelVCount, 2) * imgDpSize;
  //fonts
  static final private String fontName = "nintendo-nes-font.ttf";
  static final private int h1FontSizePx = 32;
  static final private int h2FontSizePx = 32;
  static final private int h3FontSizePx = 16;
  //colours
  final private int arcadeBackground = color(0, 0, 0);
  final private int arcadeWhite = color(255, 228, 250);
  final private int arcadeRed = color(229, 35, 53);
  final private int arcadeCyan = color(93, 235, 255);
  final private int arcadeOrange = color(255, 152, 4);
  final private int arcadeMagenta = color(255, 97, 199);
  //pixellation parameters (this is only for display)
  final private float pixelPitch = 1.05f;
  final private int pixellationSize = 1;

  //CONSTRUCTORS
  FrameData(String p1Name, String p1ImgSrc, int p1Score, String p2Name, String p2ImgSrc, int p2Score, int topScore) {
    this.p1Name = p1Name;
    this.p1ImgSrc = p1ImgSrc;
    this.p1Score = p1Score;
    this.p2Name = p2Name;
    this.p2ImgSrc = p2ImgSrc;
    this.p2Score = p2Score;
    this.topScore = topScore;
  }
}
class FrameDataBuilder {
  //VARIABLES
  private String p1Name = "ABCDEFGH";
  private String p1ImgSrc = "imgs/skaev-px.jpg";
  private int p1Score = 1415;
  private String p2Name = "IJKLMOPQ";
  private String p2ImgSrc = "imgs/klyx-px.jpg";
  private int p2Score = 625;
  private int topScore = 0;

  //physical hardware props
  FrameDataBuilder() { }

  public FrameDataBuilder p1Name(String name) {
    this.p1Name = formatArcadeStr(name);
    return this;
  }

  public FrameDataBuilder p1ImgSrc(String src) {
    this.p1ImgSrc = src;
    return this;
  }

  public FrameDataBuilder p1Score(int score) {
    this.p1Score = score;
    return this;
  }

  public FrameDataBuilder p2Name(String name) {
    this.p2Name = formatArcadeStr(name);
    return this;
  }

  public FrameDataBuilder p2ImgSrc(String src) {
    this.p2ImgSrc = src;
    return this;
  }

  public FrameDataBuilder p2Score(int score) {
    this.p2Score = score;
    return this;
  }

  public FrameDataBuilder topScore(int score) {
    this.topScore = score;
    return this;
  }

  public String formatArcadeStr(String name) {
    int maxLength = 10;
    return name.trim().toUpperCase().substring(0, Math.min(name.length(), maxLength));
  }

  public FrameData build() {
    return new FrameData(p1Name, p1ImgSrc, p1Score, p2Name, p2ImgSrc, p2Score, topScore);
  }
}
class SquareCrop {
  private int x;
  private int y;
  private int w;
  private int h;

  SquareCrop(int oW, int oH, int boxSize) {
    int boxCenter = (int) Math.floorDiv(boxSize, 2);
    this.x = Math.max(Math.floorDiv(oW, 2) - boxCenter, 0);
    this.y = Math.max(Math.floorDiv(oH, 2) - boxCenter, 0);
    this.w = Math.min(boxSize, oW);
    this.h = Math.min(boxSize, oH);
  }
}
class SquareFill {
  private int w;
  private int h;

  SquareFill(int w, int h) {
    this.w = w;
    this.h = h;
  }

  SquareFill(int oW, int oH, int toSize) {
    float scale = (float) toSize / Math.min(oW, oH);
    this.w = (int) Math.floor(oW * scale);
    this.h = (int) Math.floor(oH * scale);
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "renderer" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
